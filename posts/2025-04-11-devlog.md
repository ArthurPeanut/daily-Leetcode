---
title: Automatically Retrieving CVSS Scores to Analyze Chained Vulnerabilities
date: 2025-04-11
tags: [Crawling, HTML]
type: devlog
---
# 🧪 Devlog | Automatically Retrieving CVSS Scores to Analyze Chained Vulnerabilities

---

## 🔍 Research Motivation: Why Analyze CVSS Scores?

In the realm of cybersecurity, **chained vulnerabilities** have become increasingly relevant. Rather than relying on a single critical vulnerability, attackers often **combine multiple lower-severity CVEs** (Common Vulnerabilities and Exposures) to construct a more powerful exploit chain. These attack chains are not only harder to detect but also often bypass traditional security defenses.

Each CVE is typically assigned a **CVSS (Common Vulnerability Scoring System)** score, which rates its severity based on several characteristics—such as whether it is exploitable remotely, whether privileges are required, and what its impact on confidentiality, integrity, and availability might be.

This project was largely inspired by the following guiding questions:

> - **Analyze the CVSS score distribution of CVEs that are exploited in chained attacks.**
> - **Determine whether chained exploits are typically composed of multiple low-severity CVEs.**

Put simply, I wanted to investigate:

> 🧠 *Are chained attacks actually built from multiple low-severity vulnerabilities?*

If this hypothesis holds true, it could reshape how we prioritize patching efforts and assess risk—especially in complex environments where seemingly “low-priority” vulnerabilities might contribute to larger exploitation strategies.

---

## 🧰 The Dataset

The input was an Excel file containing several hundred CVEs. Each row represents a group of CVEs related to an exploit chain, stored in a column labeled `Column3`. Some cells contain multiple CVEs separated by commas. Another column, `Column4`, contains labels indicating whether the row corresponds to a real chained attack (marked as "是" — "Yes").

---

## 🛠️ Initial Approach: Using the NVD REST API

My first instinct was to use the [National Vulnerability Database (NVD)](https://nvd.nist.gov/developers) REST API. The process looked like this:

1. Apply for an API key from NVD.
2. For each CVE, query:`https://services.nvd.nist.gov/rest/json/cve/1.0/CVE-XXXX-YYYY`
3. Parse the JSON response to extract `baseMetricV3` or `baseMetricV2`.

### ❌ Problems Encountered:

- Many recent CVEs (especially from 2024) returned 404 errors.
- CVEs visible on the NVD website were not available via API.
- The issue? **NVD’s API is significantly delayed in publishing newer CVEs**, particularly compared to its web UI.

---

## 🌐 Switching to HTML Scraping with BeautifulSoup

Realizing the API was unreliable for newer CVEs, I shifted to **web scraping** using the NVD HTML interface. For example:

```
https://nvd.nist.gov/vuln/detail/CVE-2024-8963
```

The CVSS score is typically displayed as a button on the page. I tried:

```python
soup.find("a", {"data-testid": "vuln-cvss3-panel-score"})
```

But this failed at first. After inspecting the page, I discovered:

- The original selector (`vuln-cvss3-panel-score-nist`) was outdated.
- The actual score appeared in:
  - `data-testid="vuln-cvss3-panel-score"` (NIST)
  - `data-testid="vuln-cvss3-cna-panel-score"` (CNA fallback)

### ✅ Final logic for robustness:

```python
soup.find("a", {"data-testid": "vuln-cvss3-panel-score"})  # NIST
soup.find("a", {"data-testid": "vuln-cvss3-cna-panel-score"})  # CNA
```

I used a regular expression to extract just the numeric part from the button text:

```python
re.search(r'([0-9.]+)', text)
```

---

## 📊 Batch Processing in Excel

I refined the script into a complete pipeline:

- Load the Excel file using `pandas`;
- Filter rows where `Column4 == "是"` (i.e., confirmed chains);
- Extract all CVEs from `Column3` (supporting multiple per cell);
- Query the NVD HTML pages for each CVE;
- If the CVSS score could not be found, save the full HTML to `html_snapshots/` for later inspection;
- Write the results (e.g., `CVE-2024-8963:9.1`) into a new column `CVSS_Scores`;
- Export the updated Excel file as `gpt_results_day2_with_cvss.xlsx`.

---

## ✅ Results

Example output in the terminal:

```
CVE-2024-8963 → CVSS v3 (NIST): 9.1
CVE-2024-9379 → CVSS v3 (CNA): 7.5
...
```

And output files:

```
📁 gpt_results_day2_with_cvss.xlsx
📁 html_snapshots/
```

---

## 📈 What’s Next?

With this dataset now structured and scored, I plan to:

- Analyze the **distribution of CVSS scores** across chained vs. non-chained vulnerabilities;
- Investigate patterns in **low-severity CVEs appearing in chains**;
- Visualize score trends across chains (e.g., “low → high” escalation patterns);
- Expand the parser to extract **attack vector**, **privilege requirements**, and **CWE types**.

---

## 💡 Reflections

This project highlighted a key lesson: **open vulnerability data is rich but fragmented**, and APIs don’t always offer the most up-to-date view. Web scraping remains an essential tool when APIs lag behind.

By bridging structured data (CVEs, scores) with real-world attack chain examples, we move a step closer to understanding how attackers *actually* operate—and how defenders should *actually* prioritize patches.
