---
title: Leetcode 2360. Longest Cycle in a Graph
date: 2025-03-29
tags: [DFS, Graph]
type: leetcode
---
You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.

Return the length of the longest cycle in the graph. If no cycle exists, return -1.

A cycle is a path that starts and ends at the same node.

## Solution

```C++
class Solution {
public:
    int longestCycle(vector<int>& edges) {
        size_t n = edges.size();
        int ret = -1;
        int current_time = 1;

        vector<int> visit_time(n, 0);

        for (int i = 0; i < n; i++) {
            int next = i;
            int start_time = current_time;

            while (next != -1 && visit_time[next] == 0) {
                visit_time[next] = current_time;
                next = edges[next];

                current_time++;
            }

            if (next != -1 && start_time <= visit_time[next]) { //Only record the nodes that are visited in this cycle
                ret = ret < (current_time - visit_time[next]) ? (current_time - visit_time[next]):ret; 
            }
        }

        return ret;
    }
};
```

## Explanation

We traverse each unvisited node and follow the outgoing edges while recording the visit time. If we revisit a node during the same traversal (i.e., its visit_time is within the current pathâ€™s timestamp range), we detect a cycle and compute its length as current_time - visit_time[node]. We then update the longest cycle length accordingly.

Time complexity is O(n), since each node is visited at most once.
